<article>
    <div>
        <h1><span class="title">Character encoding primer</span></h1>
        <time datetime="2020-06-03">3 June 2020</time>
        <div class="authors">
            <span class="author">Es</span>
        </div>
        <div class="tags">
            <span class="tag">Character encoding</span>
            <span class="tag">Notes</span>
        </div>
    </div>
    <div class="post-text">

        <div class="auto-toc"></div>

        <p><span class="summary">On computers where <i>1</i> and <i>0</i> rule supreme we must have a way to express the human languages in the written format. Do do this there are standards that map characters to numeric values.</span></p>

        <p>Not all human languages use the same set of characters. Although some, like the European languages, can have varying degrees of character overlap others don't. An example of the latter is the Korean "<a href="https://en.wikipedia.org/wiki/Hangul" rel="noreferrer" target="_blank">Hangul</a>" and the Japanese "<a href="https://en.wikipedia.org/wiki/Katakana">Katakana</a>" writing systems.</p>

        <p>Even when talking about just 1 language with 1 character set, there can be a number of current competing standards. In addition, older 'legacy' standards might need to be considered when dealing with backwards compatibility.</p>

        <figure class="center half-width">
            <a href="https://xkcd.com/927/"><img src="https://imgs.xkcd.com/comics/standards.png" alt="XCDC standards"></a>
            <figcaption>Obligatory XCDC comic strip</figcaption>
        </figure>

        <p>With that in mind, let's explore the rabbit hole...</p>

        <h2>Definitions</h2>

        <p>Before jumping into encoding some domain specific vocabulary needs to be defined so that things make a little more sense.</p>

        <dl>
            <dt>Character Set</dt>
            <dd>An unordered collection of characters. <br>E.g.: the characters used in western european languages.</dd>

            <dt>Character Repertoire</dt>
            <dd>When talking in generic terms it is used interchangeably with "<i>Character Set</i>". In the <i>Unicode</i> domain, it means a full set of abstract characters that a system supports. A repertoire can either be:
                <ul>
                    <li><b>open:</b> new characters may be added to it (e.g.: Unicode), or</li>
                    <li><b>closed:</b> the standard is set and cannot be further modified (e.g.: ASCII).</li>
                </ul>
             </dd>

            <dt>Glyph</dt>
            <dd>
                <figure class="right icon">
                    <img src="kr-han.svg" alt="korean 'han' glyph"> <!-- adapted from https://en.wikipedia.org/wiki/File:Hangeul.svg -->
                </figure>
                A <i><a href="https://en.wikipedia.org/wiki/Glyph" rel="noreferrer" target="_blank">glyph</a></i> is a visual representation of a single or group of characters. Its genesis can often depend on adjacent characters.<br>E.g.: the Korean syllabic block '<span class="bold"><span style="color: red;">h</span><span style="color: blue;">a</span><span style="color: lawngreen">n</span></span>' is made up of 3 distinct characters (see right).
            </dd>

            <dt>Coded Character Set</dt>
            <dd><i>CCS</i>, also known as a "<i>Code Page</i>", maps the characters in a <i>character set</i> to <i>code points</i>. In Unix/Linux the term "<i>Charmap</i>" is more often used instead.</dd>

            <dt>Code Point</dt>
            <dd>A code point is a unique unsigned integer value that represents the position (or 'index') of a character within a <i>coded character set</i>. It is usually expressed in Hexadecimal notation. <br>E.g.: In US-ASCII where there are 127 code points, the code point of the letter 'm' is <code class="inline terminal">6D</code>.</dd>

            <dt>Code Unit</dt>
            <dd>Unit of a coded character in the <i>coded character set</i>.<br>E.g.: In US-ASCII, the code unit is 7 bits.</dd>

            <dt>Character Encoding Form</dt>
            <dd><i>CEF</i> defines how many code units there are for each <i>code points</i> and how the one maps to the other.<br>There are 2 types of encoding forms:
                <ul style="list-style-type: square;">
                    <li>Fixed width - uniformed length for all encoded characters (e.g.: US-ASCII - 1 &times; 7 bits),</li>
                    <li>Variable width - encoded characters can vary in length (e.g.: UTF-8 - 1 to 4 &times; 8 bits).</li>
                </ul>
            </dd>

            <dt>Character Encoding Scheme</dt>
            <dd><i>CES</i> is a reversible transformation of sequences of code units to sequences of bytes. It helps when saving/transmitting to octet-based file systems or networks where bytes may not be the same size.<br>E.g.: transforming a 12 &times; 16 bits UTF-16 sequence into a set of wide characters (<code class="inline terminal">wchar_t</code> type) that are defined as 32 bit long integers on the system.
            </dd>

            <dt>Code Space</dt>
            <dd>A range of <i>code points</i> in a <i>coded character set</i>. It creates sub-sections within the set and is useful when different encoding forms are used for different sub-sections. E.g.: see UTF-8.</dd>
        </dl>

        <h2>Encoding Standards</h2>

        <p>There exists a plethora of standards so I'll cover just a small selection of important ones to highlight some of the idiosyncrasies one can expect to encounter when dealing with this subject.</p>

        <h3>ASCII</h3>

        <figure class="right eighth-width">
            <img src="ASCII.svg" alt="ASCII structure">
            <figcaption>ASCII code point structure</figcaption>
        </figure>

        <p>ASCII (or American Standard Code for Information Interchange) encode 127 characters into fixed-width 7 bits unsigned integers. Why 7 bits? 1960s-era systems that ASCII was designed for used 7-bit bytes. From the 1970s things changed and systems where designed with bytes that were now 8-bits long instead.</p>

        <p>Characters 0-31 and 127 are known as "<i>control characters</i>". These are non-printing and their purpose is to send instructions to devices such as printers. Although most are now obsolete some are still in use such as the carriage return (<code class="inline terminal">CR</code>) and line feed (<code class="inline terminal">LF</code>). These are typically referred to as "<a href="https://en.wikipedia.org/wiki/C0_and_C1_control_codes#C0_controls" rel="noreferrer" target="_blank">C0</a>" control codes.</p>

        <p>Characters 32-126 are printable characters just sufficient enough to represent the English language in text format.</p>

        <div class="flex-table">
            <div class="flex-table-row">
                <div class="flex-cell flex-table-heading">
                    ASCII table
                </div>
                <div class="flex-cell">
                    <a href="ASCII%20table.pdf" rel="noreferrer" target="_blank">
                        <img class="link-icon" src="../../../img/logos/file/pdf-file.svg" alt="PDF icon">
                    </a>
                </div>
            </div>
        </div>

        <p>The extra bit gained in the 1970s was originally either set to '0' or used as a parity bit for basic error checking in network transmissions (a.k.a.: "check bit"). Later it was used to extend the ASCII table with another 128 characters bringing the total to 256. The extra space was mainly used to add basic graphic elements (e.g.: see below) to text outputs and/or add characters from other languages.</p>

        <figure class="center">
            <a href="OEM437.png" rel="noreferrer" target="_blank"><img src="OEM437-176to223.png" alt="OEM 437 char 176 to 223"></a>
            <figcaption>Graphic elements from the D.O.S. code page (176-223) (<a href="https://web.archive.org/web/20160609091246/https://msdn.microsoft.com/en-us/goglobal/cc305156" rel="noreferrer" target="_blank">OEM 437</a>)</figcaption>
        </figure>

        <p>It bears mention that, at the time, these extensions were vendor specific and not part of any standards. This led to interesting outputs when viewing files written on a computer that had a different code page... Fun times.</p>

        <h3>ISO/IEC 8859</h3>

        <figure class="right eighth-width">
            <img src="ISO8859.svg" alt="ISO 8859 structure">
            <figcaption>ISO-8859 code point structure</figcaption>
        </figure>

        <p>This standard was a joint effort from the <a href="https://www.iso.org" rel="noreferrer" target="_blank">ISO</a> (International Organization for Standardization) and the <a href="https://www.iec.ch/" rel="noreferrer" target="_blank">IEC</a> (International Electrotechnical Commission). It was made with the goal of having reliable information exchange. Since the focus was on making text readable on other machines, it meant that typography (defining character placement and the text's visual attractiveness) took a back seat.</p>

        <p>The standard defines fixed length encoding (8 bits) for characters taking the first 127 (<code class="inline terminal">00000000</code> to <code class="inline terminal">01111111</code>) in the encoding space directly from ASCII to ensure backwards compatibility with the old standard. The code points 128 to 159 have been assigned as "<a href="https://en.wikipedia.org/wiki/C0_and_C1_control_codes#C1_controls" rel="noreferrer" target="_blank">C1</a>" control codes.</p>

        <p>The standard has <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859#The_parts_of_ISO/IEC_8859" rel="noreferrer" target="_blank">16 parts</a> (minus one abandoned), each for covering languages groups that share similar characteristics (e.g.: 8859-1 for latin western european, 8859-2 for latin central european, ..., 8859-6 for latin/arabic, etc...). These parts utilise the remaining <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859#Table" rel="noreferrer" target="_blank">slots</a> (160 to 256) in the encoding to express their individual language groups.</p>

        <h3>ISO/IEC 2022</h3>

        <p>ISO/IEC 2022 was designed for data exchange and mixing different languages in documents. The way it does this is by announcing the language and, by extension, the encoding via escape sequences so that switching could occur. This technique allows multiple character sets to be represented within the space of a single character encoding system.</p>

        <p>Because of this the processing is on the complicated side of things, especially with any implementation that covers all the standard's specifications (i.e.: the different encodings). It was an answer to having multiple encodings with limited resources.</p>

        <p>That's the general idea without going too much into details. As Unicode supports the languages covered by ISO/IEC 2022 and is now more commonly used<sup>[1]</sup> along with generating less headaches, I am going to cut this section short...</p>

        <p class="footnote"><sup>[1]</sup>Emails is an area where ISO/IEC 2022 is still in use but adoption to Unicode's UTF-8 is becoming more common in that area as well.</p>

        <h3>Unicode &amp; ISO/IEC 10646</h3>

        <p>The standards were born out of the Unicode Consortium and the ISO-10646 group deciding to make a standard that would aggregate all characters from every human languages used past and present. Think of it as the mother of all <i>coded character sets</i>. The idea was to have just 1 universal <i>coded character set</i> so all systems could see the exact same characters as each other and efficiently have any number of languages used together in documents without having to switch code pages mid-way like with ISO/IEC 2022.</p>

        <p>ISO/IEC 10646 is code-for-code the same as the Unicode standard and they are both maintained concurrently. The 2 groups work together to stay in sync and when developing any extensions to the standards.</p>

        <p>The Unicode standard, when compared with ISO/IEC 10646, has extra constraints on the implementation to ensure platform and application uniformity when dealing with characters. These constraints, which include things like algorithms, functional character specifications and data, and background material are detailed in the <a href="http://www.unicode.org/versions/latest/" rel="noreferrer" target="_blank">standard's literature</a>.</p>

        <div class="information-box">
            <p>Unicode <i>code points</i> are expressed in hexadecimal notation in the form of <code class="inline terminal"><span style="color: #3474b4">U+</span><span style="color: #e97911">XX</span><span style="color: forestgreen">XX</span></code>. The <code class="inline terminal">U+</code> prefix indicates that the number following it is a Unicode <i>code point</i>. It is followed by at least <b>two</b> hexadecimal numbers.<br>For example: the character 'K' (75) in unicode is <code class="inline terminal"><span style="color: #3474b4">U+</span><span style="color: #e97911">00</span><span style="color: forestgreen">4B</span></code> and the old Persian letter '&#x103A4;' (66,468) is <code class="inline terminal"><span style="color: #3474b4">U+</span><span style="color: #663399">1</span><span style="color: #e97911">03</span><span style="color: forestgreen">A4</span></code>.</p>
        </div>

        <p>The Unicode repertoire spanning <code class="inline terminal">U+0000</code> to <code class="inline terminal">U+10FFFF</code> is divided into 17 "<i>planes</i>" which are, in turn, broken into named "<i>blocks</i>" of related characters.</p>

        <table class="basic-table">
            <tr>
                <th>Plane</th>
                <th>Code space</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>0</td>
                <td><code class="inline terminal">U+0000</code> to <code class="inline terminal">U+FFFF</code></td>
                <td>Basic Multilingual Plane</td>
            </tr>
            <tr>
                <td>1</td>
                <td><code class="inline terminal">U+10000</code> to <code class="inline terminal">U+1FFFF</code></td>
                <td>Supplementary Multilingual Plane</td>
            </tr>
            <tr>
                <td>2</td>
                <td><code class="inline terminal">U+20000</code> to <code class="inline terminal">U+​2FFFF</code></td>
                <td>Supplementary Ideographic Plane</td>
            </tr>
            <tr>
                <td>3</td>
                <td><code class="inline terminal">U+30000</code> to <code class="inline terminal">U+​3FFFF</code></td>
                <td>Tertiary Ideographic Plane</td>
            </tr>
            <tr>
                <td>4-13</td>
                <td><code class="inline terminal">U+40000</code> to <code class="inline terminal">U+​DFFFF</code></td>
                <td><i>unassigned</i></td>
            </tr>
            <tr>
                <td>14</td>
                <td><code class="inline terminal">U+E0000</code> to <code class="inline terminal">U+​EFFFF</code></td>
                <td>Supplement­ary Special-purpose Plane</td>
            </tr>
            <tr>
                <td>15-16</td>
                <td><code class="inline terminal">U+F0000</code> to <code class="inline terminal">U+10FFFF</code></td>
                <td>Supplement­ary Private Use Area planes</td>
            </tr>
        </table>

        <p>For example, the Basic Multilingual Plane (<a href="https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF" rel="noreferrer" target="_blank">BMP</a>) contains blocks such as "Latin Extended-A", "Latin Extended-B", "Cyrillic", "Hebrew" and "Tibetan" to name a few.</p>

        <p>Abstract characters in the Unicode <i>character set</i> are encoded by association to particular <i>code points</i> but it is important to be aware that not all characters are associated to a single Unicode <i>code point</i>. Some characters are represented with a sequence of these <i>code points</i>. These 'composite' or 'pre-composed' <i>code points</i> are there for the sake of efficiency and not having to encode all the individual parts and take up more space in memory as a consequence.</p>

        <figure class="third-width right">
            <img src="kr-han-decomp.svg" alt="Korean HAN decomposition">
            <figcaption>Unicode decomposition of the Korean glyph 'HAN'</figcaption>
        </figure>

        <p>E.g.: Taking our previous example of the Korean 'han' glyph (한) its unicode point is <code class="inline terminal">U+D55C</code> but that is actually composed of 3 other individual <i>code points</i> (see fig).</p>

        <p>For Unicode there are currently 2 different encoding methods:</p>
        <ol>
            <li>The "Universal Coded Character Set" (UCS) that comprises of
                <ul>
                    <li>UCS-2 (obsolete, now replaced by UTF-16), and</li>
                    <li>UCS-4 (functionally equivalent to UTF-32).</li>
                </ul>
            </li>
            <li>The "Unicode Transformation Format" (UTF) which includes
                <ul>
                    <li>UTF-8,</li>
                    <li>UTF-16,</li>
                    <li>UTF-32.</li>
                </ul>
            </li>
        </ol>

        <p>The most commonly used encodings are UTF-8 and UTF-16.</p>

        <h4>UCS</h4>

        <p>The "Universal Coded Character Set" (ISO/IEC 10646) or "UCS" for short defines the <b>fixed length</b> <i>code points</i> for the Unicode character repertoire.</p>

        <p>Originally the Unicode consortium decided to have the repertoire hold all characters from all <b>modern and in-use human languages of the world</b>. The previous 8 bit fixed encoding was doubled to 16 bit allowing a whopping 65,536 characters for the task.</p>

        <p>In 1996 the Unicode consortium decided that this wasn't enough and all characters from all human languages that have ever existed in the world needed to be included as well. The original 2<sup>16</sup> <i>code points</i> was not even nearly enough for doing that in reality.</p>

        <figure class="third-width right">
            <a href="encoding-bits.svg"><img src="encoding-bits.svg" alt="UCS/UTF encoding bits"></a>
            <figcaption>Encoding units for UCS and UTF</figcaption>
        </figure>

        <p>"UCS-4" (also referred to UTF-32) doubled UCS-2's fixed encoding to 32 bit (or 4 bytes) which made it now possible to hold the complete extensions of Unicode and some more. This solution is memory intensive and incredibly wasteful as everything in this <i>encoding form</i> is 32 bits long.</p>

        <h4>UTF</h4>

        <p>Unicode Transformation Format is a set of multi-byte encoding schemes that map to unicode code points and can represent more than 2 billion characters.</p>

        <h5>UTF-8</h5>

        <p>UTF-8 is a <b>variable width</b> encoding of UCS-2 or UCS-4 which offers two-way compatibility with ASCII (range <code class="inline terminal">0</code> to <code class="inline terminal">127</code>). The encoded characters spans 1 to 4 &times; 8-bit bytes each and can represent the first 2<sup>21</sup> Unicode <i>code points</i>.</p>

        <table class="basic-table">
            <tr>
                <th>Code Space</th>
                <th>Code Form binary sequence</th>
            </tr>
            <tr>
                <td><code class="inline terminal">U+0000</code> to <code class="inline terminal">U+007F</code></td>
                <td style="text-align:left;"><code class="inline terminal">0xxxxxxx</code></td>
            </tr>
            <tr>
                <td><code class="inline terminal">U+0080</code> to <code class="inline terminal">U+07FF</code></td>
                <td style="text-align:left;"><code class="inline terminal">110xxxxx 10xxxxxx</code></td>
            </tr>
            <tr>
                <td><code class="inline terminal">U+0800</code> to <code class="inline terminal">U+D7FF</code><br>
                    <code class="inline terminal">U+E000</code> to <code class="inline terminal">U+FFFF</code></td>
                <td style="text-align:left;"><code class="inline terminal">1110xxxx 10xxxxxx 10xxxxxx</code></td>
            </tr>
            <tr>
                <td><code class="inline terminal">U+10000</code> to <code class="inline terminal">U+10FFFF</code></td>
                <td style="text-align:left;"><code class="inline terminal">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code></td>
            </tr>
        </table>

        <p>UTF-8 doesn't have code points beyond <code class="inline terminal">U+10FFFF</code> as it is limited in <a href="https://tools.ietf.org/html/rfc3629#section-12" rel="noreferrer" target="_blank">RFC 3629 (sec.12)</a> to have the same limit as UTF-16.</p>

        <h5>UTF-16</h5>

        <p>UTF-16 is the default encoding for the Unicode standard and, as it's name suggests, uses 16 bits code units. There can be up to 2 of these for any <i>code points</i>.</p>

        <table class="basic-table">
            <tr>
                <th>Code Space</th>
                <th>Code Form</th>
            </tr>
            <tr>
                <td><code class="inline terminal">U+0000</code> to <code class="inline terminal">U+D7FF</code><br>
                    <code class="inline terminal">U+E000</code> to <code class="inline terminal">U+FFFF</code></td>
                <td style="text-align:left;">1 &times; 16 bits</td>
            </tr>
            <tr>
                <td><code class="inline terminal">U+10000</code> to <code class="inline terminal">U+10FFFF</code></td>
                <td style="text-align:left;">2 &times; 16 bits</td>
            </tr>
        </table>

        <p>Elements in the first ranges encoding to 1 &times; 16 bits all map to numerically equivalent <i>code points</i> in Unicode whereas the 2 &times; 16 bits range require some calculations to take place. These are called "surrogate pairs".</p>

        <div class="information-box">
            <h5>Converting Unicode code points beyond <code class="inline terminal">U+FFFF</code> to UTF-16</h5>
            <ol>
                <li><code>UCP</code> is a Unicode <i>code point</i> that is in the <code class="inline terminal">0x10000</code> to <code class="inline terminal">0x10FFFF</code> range.<br>
                    <code>UCP'</code> &equals; <code>UCP</code> &minus; <code class="inline terminal">0x10000</code></li>
                <li>The resulting <code>UCP'</code> value is cut mid way to get 2 &times; 10 bits Hex value (<code>UCP'<sub>high</sub></code> and <code>UCP'<sub>low</sub></code>).</li>
                <li><code>W<sub>high</sub></code> &equals; <code class="inline terminal">0xD800</code> &plus; <code>UCP'<sub>high</sub></code><br>
                    <code>W<sub>low</sub></code> &equals; <code class="inline terminal">0xDC00</code> &plus;  <code>UCP'<sub>low</sub></code></li>
            </ol>
        </div>

        <p><b>Example:</b> converting the egyptian cat hieroglyph<sup>[2]</sup> <a href="cat-hieroglyph.png">&#78048;</a> (<code class="inline terminal">U+130E0</code>) to UTF-16...</p>
        <ol>
            <li><code>UCP'<sub>16</sub></code> &equals; <code class="inline terminal">0x130E0</code> &minus; <code class="inline terminal">0x10000</code><br>
                <code>UCP'<sub>16</sub></code> &equals; <code class="inline terminal">0x030E0</code><br>
                <code>UCP'<sub>2</sub></code> &equals; <code class="inline terminal">0b<span style="color: #2a7ae2">0000001100</span><span style="color:#aa0000;">0011100000</span></code></li>

            <li><code>UCP'<sub>high</sub></code> &equals; <code class="inline terminal"><span style="color: #2a7ae2">0x000C</span></code><br>
                <code>UCP'<sub>low</sub></code> &equals; <code class="inline terminal"><span style="color: #aa0000">0x00E0</span></code></li>

            <li><code>W<sub>high</sub></code> &equals; <code class="inline terminal">0xD800</code> &plus; <code class="inline terminal"><span style="color: #2a7ae2">0x000C</span></code> &equals; <code class="inline terminal">0xD80C</code><br>
                <code>W<sub>low</sub></code> &equals; <code class="inline terminal">0xDC00</code> &plus;  <code class="inline terminal"><span style="color: #aa0000">0x00E0</span></code> &equals; <code class="inline terminal">0xDCE0</code></li>

            <li>All that's left is to concatenate the two results leaving us with the UTF-16 hex encoding of <code class="inline terminal">D8 0C DC E0</code></li>
        </ol>

        <p>One thing to note is that the valid ranges for high surrogates (<code class="inline terminal">0xD800</code>-<code class="inline terminal">0xDBFF</code>), low surrogates (<code class="inline terminal">0xDC00</code>-<code class="inline terminal">0xDFFF</code>) and valid Basic Multilingual Plane characters (<code class="inline terminal">0x0000</code>-<code class="inline terminal">0xD7FF</code>, <code class="inline terminal">0xE000</code>-<code class="inline terminal">0xFFFF</code>) do not overlap.</p>

        <p>Windows (NT to 10), Java, .Net, Javascript and many Windows-based text editors all use UTF-16 internally whereas Linux and Mac OSX use UTF-8 now.</p>

        <p class="footnote"><sup>[2]</sup><a href="https://www.unicode.org/charts/PDF/U13000.pdf" rel="noreferrer" target="_blank">Official Unicode Consortium code chart: Egyptian Hieroglyphs</a></p>

        <h5>UTF-32</h5>

        <p>Equivalent to UCS-4, this is most straight forward encoding to deal with but at the cost of much higher memory usage. This <b>fixed width</b> encoding uses a single <i>code unit</i> that is 32 bits long.</p>

        <p>Each of the values in UTF-32 corresponds to the equivalent Unicode <i>code point</i>'s value. This has advantages in performance as jumping to a particular code point in a string can be done in <code>O(1)</code> time like an array since all <i>code points</i> are encoded the same size. In variable length encoding like UTF-8 and UTF-16, reaching a particular index can only be done by iterating through the string (<code>O(N)</code> time like a linked list).</p>

        <div class="information-box">
            <p><b>Development note:</b> in Linux a <code class="inline terminal">wchar_t</code> wide character type is 32 bits long whereas in Windows it is 16 bits long.</p>
        </div>

        <h4>Unicode Byte-Order Mark</h4>

        <p>A byte-order mark (or "BOM" for short) is a magic number at the beginning of a stream or string that tells the decoding application whether the encoding used to write the file used a Big-endian or Small-endian byte ordering.</p>

        <div class="information-box">
            <p><b>Endianness</b> is the order in which bytes in a word<sup>[a]</sup> are stored and read in computer memory or during transmission. E.g.: Assuming a 32-bit word architecture where 4 &times; 8 bit characters can be squeezed into a word, a string 'Hello!' (<code class="inline terminal"><span style="color: #2a7ae2;">48 65 6C 6C</span> <span style="color: #e97911;">6F 21</span></code>) in a Big-Endian system will be <code class="inline terminal"><span style="color: #2a7ae2;">48 65 6C 6C</span> <span style="color: #e97911;">6F 21 00 00</span></code> whilst on a Small-Endian system it will be <code class="inline terminal"><span style="color: #2a7ae2;">6C 6C 65 48</span> <span style="color: #e97911;">00 00 21 6F</span></code>.</p>

            <p class="footnote"><sup>[a]</sup>A word is the natural unit of data used in a particular processor design. Newer x86 architectures currently use 64 bit words for example.</p>
        </div>

        <p>UCS-2 and UTF-16 use this feature in their encoding with the BOM '<code class="inline terminal">U+FEFF</code>'.</p>

        <p>As for UTF-8, the Unicode standard allows it but does not specify its requirement (<a href="https://tools.ietf.org/html/rfc3629#section-6" rel="noreferrer" target="_blank">RFC 3629, section 6</a>). BOM in this context only serve to signal that the text stream is encoded as UTF-8. Microsoft's application (notepad, compiler, interpreters, etc...) require a BOM at the beginning of a file even when dealing with UTF-8.</p>

        <p>UTF-32 only really requires a BOM when used (rare case) for transmission. In this case the same rules as UTF-16 are applicable.</p>

        <table class="basic-table">
            <tr>
                <th>Encoding</th>
                <th>BOM</th>
            </tr>
            <tr>
                <td style="text-align:left;">UTF-8</td>
                <td style="text-align:left;"><code class="inline terminal">EF BB BF</code></td>
            </tr>
            <tr>
                <td style="text-align:left;">UTF-16 (Big-Endian)</td>
                <td style="text-align:left;"><code class="inline terminal">FE FF</code></td>
            </tr>
            <tr>
                <td style="text-align:left;">UTF-16 (Small-Endian)</td>
                <td style="text-align:left;"><code class="inline terminal">FF FE</code></td>
            </tr>
            <tr>
                <td style="text-align:left;">UTF-32 (Big-Endian)</td>
                <td style="text-align:left;"><code class="inline terminal">00 00 FE FF</code></td>
            </tr>
            <tr>
                <td style="text-align:left;">UTF-32 (Small-Endian)</td>
                <td style="text-align:left;"><code class="inline terminal">FF FE 00 00</code></td>
            </tr>
        </table>

        <h2>A final comment</h2>

        <p>The topic of character encoding can be seen as both vast and perilous. It's all too easy to just ignore which is unfortunate as it is a rather important subject. In many instances the language or framework kinda insulate the developer from all the encoding stuff by doing background Voodoo and natively using UTF-8/16. Unless you come across a case where the incoming data stream or the system where the application is run does not use these exact encodings you can go on with development completely oblivious that a string may not always contain what you might expect.</p>

        <p>There is so much more to this subject than what I covered here.</p>

        <div class="comment-box">
            <p>I have been guilty of overlooking this important topic in the past and it sort of came back to bite me in the arse by way of cornering me architecturally. As a certain <a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/" rel="noreferrer" target="_blank">famous software engineering blog post</a> put it there are really no excuses in the end not to know at least some basics...</p>
        </div>

        <h2>Resources &amp; References</h2>

        <figure class="right">
            <a href="kitteh.txt" rel="noreferrer" target="_blank"><img src="ascii-art.png" style="width: 200px; height: 200px;" alt="ascii kitteh"></a>
            <figcaption>ASCII art kitteh (made with <a href="https://github.com/tzvetkoff/im2a" rel="noreferrer" target="_blank"><code class="inline terminal">im2a</code></a>)</figcaption>
        </figure>

        <ul>
            <li><a href="http://www.unicode.org/versions/latest/" rel="noreferrer" target="_blank">Unicode Standard</a></li>
            <li><a href="https://standards.iso.org/ittf/PubliclyAvailableStandards/index.html" rel="noreferrer" target="_blank">Publicly available ISO standards</a></li>
            <li><a href="http://site.icu-project.org/" rel="noreferrer" target="_blank">International Components for Unicode library (C/C++/Java)</a></li>
            <li><a href="https://tools.ietf.org/html/rfc3629" rel="noreferrer" target="_blank">RFC 3629: UTF-8, a transformation format of ISO 10646</a></li>
            <li><a href="https://www.w3.org/International/articles/definitions-characters/" rel="noreferrer" target="_blank">Character encodings: Essential concepts (W3.org)</a></li>
            <li><a href="https://unicode.org/reports/tr17/" rel="noreferrer" target="_blank">Unicode Technical Report #17: Unicode Character Encoding Model</a></li>
            <li><a href="https://www.cl.cam.ac.uk/~mgk25/unicode.html" rel="noreferrer" target="_blank">UTF-8 and Unicode FAQ for Unix/Linux (Markus Kuhn, 1999)</a></li>
            <li><a href="https://utf8everywhere.org/" rel="noreferrer" target="_blank">The UTF-8 Everywhere Manifesto</a></li>
        </ul>



    </div>
</article>
